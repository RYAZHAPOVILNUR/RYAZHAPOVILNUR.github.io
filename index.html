<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<hr>
<p class="has-line-data" data-line-start="1" data-line-end="5">description: ‘Самая известная и широко используемая библиотека реактивного программирования на JavaScript - это RxJS…’<br>
  title: “Что нового в RxJS 7”<br>
  date: 2021-06-23T20:29:14+05:00<br>
  draft: false</p>
<hr>
<h2 class="code-line" data-line-start=8 data-line-end=9 ><a id="___RxJS_7_8"></a>Что нового в RxJS 7</h2>
<h4 class="code-line" data-line-start=10 data-line-end=11 ><a id="_________JavaScript___RxJS__________25__23x_React_97x_Angular_11x_Vue___RxJS_6_3__RxJS_7________2019_____________RxJS_7_____RxJS_7__6_____RxJS_7_10"></a>Самая известная и широко используемая библиотека реактивного программирования на JavaScript - это RxJS. Настолько, что количество загрузок в неделю сегодня составляет около 25 миллионов (2,3x React, 9,7x Angular, 11x Vue). Мы используем RxJS 6 3 года. RxJS 7, первая альфа-версия которого была выпущена в сентябре 2019 года, был выпущен шесть дней назад. Итак, какие изменения ждут нас в RxJS 7? В чем разница между RxJS 7 и 6? Стоит ли переходить на RxJS 7?</h4>
<h3 class="code-line" data-line-start=12 data-line-end=13 ><a id="TypeScript______RxJS_7_12"></a>TypeScript, размер, память и скорость в RxJS 7</h3>
<h3 class="code-line" data-line-start=14 data-line-end=15 ><a id="__14"></a>Улучшенные типы</h3>
<h4 class="code-line" data-line-start=16 data-line-end=17 ><a id="_____RxJS_7________________________16"></a>Одно из основных изменений в RxJS 7, пожалуй, наименее заметное. Когда мы смотрим на журнал изменений, мы видим, что над типами проделано много работы. Особенно выделяются результаты по следующим темам:</h4>
<ul>
  <li class="has-line-data" data-line-start="18" data-line-end="20">
    <h3 class="code-line" data-line-start=18 data-line-end=19 ><a id="__n____of___________89__18"></a>Функции, принимающие <code>n</code> параметры, такие как <code>of</code>, теперь могут правильно определять типы, даже если им передано более 8–9 параметров.</h3>
  </li>
</ul>
<pre><code class="has-line-data" data-line-start="21" data-line-end="26">import { of } from &quot;rxjs&quot;;

// Observable&lt;string, number&gt; (in RxJS 6 → No overload matches this call)
of(0, &quot;A&quot;, 1, &quot;B&quot;, 2, &quot;C&quot;, 3, &quot;D&quot;, 4, &quot;E&quot;, 5, &quot;F&quot;, 6, &quot;G&quot;, 7, &quot;H&quot;, 8, &quot;I&quot;, 9, &quot;...&quot;);
</code></pre>
<ul>
  <li class="has-line-data" data-line-start="27" data-line-end="29">
    <h3 class="code-line" data-line-start=27 data-line-end=28 ><a id="_______groupBy_______key_27"></a>Мы можем разделить группы, созданные с помощью, <code>groupBy</code> на их типы в соответствии с <code>key</code>.</h3>
  </li>
</ul>
<pre><code class="has-line-data" data-line-start="30" data-line-end="42">import { of } from &quot;rxjs&quot;;
import { groupBy, map, mergeMap } from &quot;rxjs/operators&quot;;

// Observable&lt;string, number&gt;
of(0, &quot;A&quot;, 1, &quot;B&quot;, 2, &quot;C&quot;, 3, &quot;D&quot;, 4, &quot;E&quot;, 5, &quot;F&quot;, 6, &quot;G&quot;, 7, &quot;H&quot;, 8, &quot;I&quot;, 9, &quot;...&quot;)
  .pipe(
    groupBy((x): x is number =&gt; typeof x === &quot;number&quot;),
    mergeMap(group$ =&gt; (group$.key === true ? group$.pipe(map(String)) : group$))
  )
  .subscribe();
// Observable&lt;string&gt; (in RxJS 6 → Observable&lt;string | number&gt;)
</code></pre>
<ul>
  <li class="has-line-data" data-line-start="43" data-line-end="45">
    <h3 class="code-line" data-line-start=43 data-line-end=44 ><a id="__filterBoolean_________43"></a>С помощью <code>filter(Boolean)</code> мы можем отфильтровать типы, которые не соответствуют условию.</h3>
  </li>
</ul>
<pre><code class="has-line-data" data-line-start="46" data-line-end="55">import { of } from &quot;rxjs&quot;;
import { filter } from &quot;rxjs/operators&quot;;

// Observable&lt;&quot;&quot; | 0 | null | undefined | Date&gt;
of(&quot;&quot; as const, 0 as const, null, undefined, new Date())
  .pipe(filter(Boolean))
  .subscribe();
// Observable&lt;Date&gt; (in RxJS 6 → Observable&lt;unknown&gt;)
</code></pre>
<ul>
  <li class="has-line-data" data-line-start="56" data-line-end="58">
    <h3 class="code-line" data-line-start=56 data-line-end=57 ><a id="__next___Subject_56"></a>Теперь метод <code>next</code> учитывает тип <code>Subject</code>.</h3>
  </li>
</ul>
<pre><code class="has-line-data" data-line-start="59" data-line-end="67">import { Subject } from &quot;rxjs&quot;;

const number$ = new Subject&lt;number&gt;();
number$.next();

// Error: An argument for 'value' was not provided.
// in RxJS 6 → No error
</code></pre>
<h3 class="code-line" data-line-start=68 data-line-end=69 ><a id="___68"></a>Меньший размер бандла</h3>
<h4 class="code-line" data-line-start=70 data-line-end=71 ><a id="________________39________________Angular____70"></a>Бен Леш говорит, что, перебирая всю библиотеку шаг за шагом, они уменьшили общий размер пакета на 39% . Это большие усилия и достойный внимания результат. Итак, я попробовал это в небольшом проекте Angular. Результаты приведены ниже:</h4>
<h5 class="code-line" data-line-start=72 data-line-end=73 ><a id="_____RxJS_6_72"></a>Таблица, показывающая размер пакета с RxJS 6</h5>
<p class="has-line-data" data-line-start="73" data-line-end="74"><img src="https://miro.medium.com/max/2400/1*tweVlLxR0Nt6Mh9iphUr4g.png" alt=""></p>
<h6 class="code-line" data-line-start=74 data-line-end=75 ><a id="__RxJS_6_74"></a>размер пакета RxJS 6</h6>
<h5 class="code-line" data-line-start=77 data-line-end=78 ><a id="_____RxJS_7_77"></a>Таблица, показывающая размер пакета с RxJS 7</h5>
<p class="has-line-data" data-line-start="78" data-line-end="79"><img src="https://miro.medium.com/max/2400/1*eFTkodeI0S2ca1flpkbL5Q.png" alt=""></p>
<h6 class="code-line" data-line-start=79 data-line-end=80 ><a id="__RxJS_7_79"></a>размер пакета RxJS 7</h6>
<h4 class="code-line" data-line-start=81 data-line-end=82 ><a id="__RxJS_7__RxJS_6____10_____________________________81"></a>Использование только RxJS 7 вместо RxJS 6, имело эффект на 10 КБ на общий размер пакета. Неплохо для небольшого приложения. Кроме того, мы видим, что это изменение больше повлияло на размер ленивого фрагмента, в котором я использовал много операторов.</h4>
<h3 class="code-line" data-line-start=83 data-line-end=84 ><a id="___83"></a>Меньше потребление памяти</h3>
<h4 class="code-line" data-line-start=85 data-line-end=86 ><a id="_RxJS__Observable____Observable__observable___85"></a>В RxJS, тот <code>Observable</code>, который эмитит другой <code>Observable</code> - «observable высшего порядка».</h4>
<pre><code class="has-line-data" data-line-start="88" data-line-end="105">import { of } from &quot;rxjs&quot;;
import { map, concatAll } from &quot;rxjs/operators&quot;;

of(1, 2, 3)
  .pipe(
    map(id =&gt;
      fromFetch(`https://jsonplaceholder.typicode.com/todos/${id}`, {
        selector: resp =&gt; resp.json()
      })
    ),
    concatAll()
  )
  .subscribe(todo =&gt; console.log(todo.title));
// (after some time) delectus aut autem
// (after some time) quis ut nam facilis et officia qui
// (after some time) fugiat veniam minus
</code></pre>
<h4 class="code-line" data-line-start=106 data-line-end=107 ><a id="_Observable____c_of___observable_______fromFetch___observable__RxJS_6__________RxJS_7___________106"></a>Этот <code>Observable</code>, что мы создали c <code>of</code>, называется «внешним observable», а то, что мы создали с <code>fromFetch</code> называется «внутренним observable». В RxJS 6 операторы также фиксируют значения, испускаемые внешними наблюдаемыми объектами. В RxJS 7 устранена необходимость в захвате внешних значений и снижено потребление памяти.</h4>
<h3 class="code-line" data-line-start=108 data-line-end=109 ><a id="__RxJS_108"></a>Более быстрый RxJS</h3>
<h4 class="code-line" data-line-start=110 data-line-end=111 ><a id="_______________________110"></a>Честно говоря, сам не пробовал. Описания Бен Леша и то, что я слышал здесь и там, относятся к этому направлению. См. Твит ниже:</h4>
<p class="has-line-data" data-line-start="112" data-line-end="113"><img src="https://miro.medium.com/max/2400/1*Zf70uoDVGWWyEkm405cjkw.png" alt=""></p>
<h4 class="code-line" data-line-start=114 data-line-end=115 ><a id="_____RxJS_7___20__114"></a>Твит, в котором утверждается, что RxJS 7 примерно на 20% быстрее</h4>
<h4 class="code-line" data-line-start=115 data-line-end=116 ><a id="______20_____________115"></a>Конечно, в твите не говорится, что «20%» - это фиксированное значение, рефакторинг и улучшения кодовой базы, должно быть, сработали.</h4>
<blockquote>
  <h4 class="code-line" data-line-start=116 data-line-end=117 ><a id="_____________for_await_____116"></a>Возможно, вы видели это в твите, но не слишком волнуйтесь: поддержка для с <code>for await</code> тех пор была удалена.</h4>
</blockquote>
<h3 class="code-line" data-line-start=118 data-line-end=119 ><a id="_____RxJS_7_118"></a>Примечательные особенности и изменения в RxJS 7</h3>
<h3 class="code-line" data-line-start=120 data-line-end=121 ><a id="toPromise__firstValueFrom_lastValueFrom_120"></a>toPromise → firstValueFrom, lastValueFrom</h3>
<h4 class="code-line" data-line-start=122 data-line-end=123 ><a id="_________RxJS_6_toPromise______________toPromise______RxJS_7______toPromise_________________undefined_______TypeScript____122"></a>Начнем с изменения, о котором слышало большинство людей, использующих RxJS 6: <code>toPromise</code> теперь устарело. Но не бойтесь, он еще не удален из библиотеки. Таким образом, <code>toPromise</code> все еще можно использовать в RxJS 7. Однако я предлагаю вам убрать <code>toPromise</code> из своего проекта, потому что он будет скоро удален. Кроме того, для возвращаемого типа устанавливается значение <code>undefined</code>, что может нарушить работу проектов, использующих TypeScript в строгом режиме.</h4>
<h4 class="code-line" data-line-start=124 data-line-end=125 ><a id="____________toPromise_124"></a>Так во что вы можете переформатировать это? Для начала вспомним, как работает <code>toPromise</code>:</h4>
<pre><code class="has-line-data" data-line-start="127" data-line-end="138">import { interval } from &quot;rxjs&quot;;
import { map, take } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

count1To5$.toPromise().then(console.log);
// (after ~5s) 5
</code></pre>
<h4 class="code-line" data-line-start=139 data-line-end=140 ><a id="_5_a__1____toPromise__Promise__________Observable__RxJS_7__toPromise_______firstValueFrom__lastValueFrom_139"></a>Почему <code>5</code>, a не <code>1</code>? Это потому, что <code>toPromise</code> возвращает <code>Promise</code>, который резолвит с последнее значение, выпущенное при завершении источника <code>Observable</code>. В RxJS 7 вместо <code>toPromise</code>, мы можем использовать две разные функции: <code>firstValueFrom</code> и <code>lastValueFrom</code>.</h4>
<pre><code class="has-line-data" data-line-start="142" data-line-end="156">import { interval, firstValueFrom, lastValueFrom } from &quot;rxjs&quot;;
import { map, take } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

firstValueFrom(count1To5$).then(console.log);
// (after ~1s) 1

lastValueFrom(count1To5$).then(console.log);
// (after ~5s) 5
</code></pre>
<h4 class="code-line" data-line-start=157 data-line-end=158 ><a id="_______lastValueFrom__toPromise_____toPromise__undefined___Observable_____157"></a>Если вам интересно, есть ли разница между <code>lastValueFrom</code> и <code>toPromise</code>, да, есть. А именно, <code>toPromise</code> вернет <code>undefined</code>, если источник <code>Observable</code> завершится без выдачи значения.</h4>
<h4 class="code-line" data-line-start=159 data-line-end=160 ><a id="_____159"></a>Это немного неверно, потому что:</h4>
<ul>
  <li class="has-line-data" data-line-start="160" data-line-end="161">
    <h4 class="code-line" data-line-start=160 data-line-end=161 ><a id="Promise__toPromise____undefined______160"></a><code>Promise</code>, возвращаемый <code>toPromise</code> действительно может возвращать <code>undefined</code>. Невозможно отличить от состояния ошибки.</h4>
  </li>
  <li class="has-line-data" data-line-start="161" data-line-end="163">
    <h4 class="code-line" data-line-start=161 data-line-end=162 ><a id="_________161"></a>Случай, когда значение не передается, следует рассматривать как ошибку.</h4>
  </li>
</ul>
<h4 class="code-line" data-line-start=163 data-line-end=164 ><a id="__lastValueFrom______EmptyErrorImpl__Observable_________catch____163"></a>Новая функция <code>lastValueFrom</code> выдает настраиваемую ошибку с формой <code>EmptyErrorImpl</code>, когда <code>Observable</code> завершается без выдачи значения. Обратите внимание на использование <code>catch</code> в примере ниже.</h4>
<pre><code class="has-line-data" data-line-start="166" data-line-end="171">import { EMPTY, firstValueFrom } from &quot;rxjs&quot;;

lastValueFrom(EMPTY).catch(console.log);
// (asynchronously) EmptyErrorImpl
</code></pre>
<h4 class="code-line" data-line-start=172 data-line-end=173 ><a id="____________EmptyError_172"></a>Итак, как мы обнаруживаем эту ошибку? Мы будем использовать для этого класс <code>EmptyError</code>.</h4>
<h4 class="code-line" data-line-start=173 data-line-end=174 ><a id="___EmptyError__EmptyErrorImpl__________________173"></a>Не запутайтесь между <code>EmptyError</code> и <code>EmptyErrorImpl</code>. Следующая часть исходного кода объясняет, почему мы видим два разных имени для одной и той же ошибки:</h4>
<pre><code class="has-line-data" data-line-start="176" data-line-end="185">export const EmptyError: EmptyErrorCtor = createErrorClass(
  _super =&gt;
    function EmptyErrorImpl(this: any) {
      _super(this);
      this.name = &quot;EmptyError&quot;;
      this.message = &quot;no elements in sequence&quot;;
    }
);
</code></pre>
<h4 class="code-line" data-line-start=186 data-line-end=187 ><a id="_________186"></a>Вы можете подумать, почему бы не сделать вот так:</h4>
<pre><code class="has-line-data" data-line-start="189" data-line-end="196">export class EmptyError extends Error {
  constructor() {
    super(&quot;no elements in sequence&quot;);
    this.name = &quot;EmptyError&quot;;
  }
}
</code></pre>
<h4 class="code-line" data-line-start=196 data-line-end=197 ><a id="_____new_EmptyError_instanceof_EmptyError____true___TypeScript___ES5___false__TypeScript__12123___RxJS__Objectcreate_______constructor______________RxJS_196"></a>Причина в том, что при <code>new EmptyError() instanceof EmptyError</code>, ожидается возврат выражения true, но когда TypeScript скомпилирован в ES5, он возвращает false. (См. TypeScript # 12123 ). Команда RxJS использовала <code>Object.create</code> для решения этой проблемы, и название <code>constructor</code> ошибки отличается от типа ошибки. Этот подход применяется ко всем настраиваемым ошибкам, выдаваемым RxJS.</h4>
<blockquote>
  <h4 class="code-line" data-line-start=198 data-line-end=199 ><a id="______________noshadowedvariable__TSLint_______198"></a>У них могло быть одно и то же имя, но эта фиксация остановила переопределение no-shadowed-variable правила TSLint и потребовала, чтобы имена были разными.</h4>
</blockquote>
<h3 class="code-line" data-line-start=200 data-line-end=201 ><a id="combineLatest_observable_dictionary_200"></a>combineLatest observable dictionary</h3>
<h4 class="code-line" data-line-start=202 data-line-end=203 ><a id="_RxJS_6_____Observable___forkJoin_202"></a>В RxJS 6 мы могли передавать словари <code>Observable</code> в файлы <code>forkJoin</code>.</h4>
<pre><code class="has-line-data" data-line-start="205" data-line-end="221">import { forkJoin, interval } from &quot;rxjs&quot;;
import { map } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

forkJoin({ x: count1to5$, y: count6to9$ }).subscribe(console.log);
// (after ~5s) {x: 5, y: 9}
</code></pre>
<h4 class="code-line" data-line-start=222 data-line-end=223 ><a id="_____combineLatest__RxJS_7_222"></a>Теперь это также возможно с <code>combineLatest</code> в RxJS 7.</h4>
<pre><code class="has-line-data" data-line-start="225" data-line-end="245">import { combineLatest, interval } from &quot;rxjs&quot;;
import { map } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

combineLatest({ x: count1to5$, y: count6to9$ }).subscribe(console.log);
// (after ~1s) {x: 1, y: 6}
// (after ~1s) {x: 2, y: 6} (immediately) {x: 2, y: 7}
// (after ~1s) {x: 3, y: 7} (immediately) {x: 3, y: 8}
// (after ~1s) {x: 4, y: 8} (immediately) {x: 4, y: 9}
// (after ~1s) {x: 5, y: 9}
</code></pre>
<h3 class="code-line" data-line-start=245 data-line-end=246 ><a id="combineLatestWith_245"></a>combineLatestWith</h3>
<h4 class="code-line" data-line-start=247 data-line-end=248 ><a id="_combineLatest_____RxJS_6_247"></a>Оператор <code>combineLatest</code> был устаревшим уже в RxJS 6.</h4>
<pre><code class="has-line-data" data-line-start="250" data-line-end="270">import { interval } from &quot;rxjs&quot;;
import { combineLatest, map } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(combineLatest(count6To9$)).subscribe(console.log);
// (after ~1s) [1,6]
// (after ~1s) [2,6] (immediately) [2,7]
// (after ~1s) [3,7] (immediately) [3,8]
// (after ~1s) [4,8] (immediately) [4,9]
// (after ~1s) [5,9]
</code></pre>
<h4 class="code-line" data-line-start=271 data-line-end=272 ><a id="_RxJS_7____combineLatestWith_271"></a>В RxJS 7 его заменил оператор <code>combineLatestWith</code>.</h4>
<h3 class="code-line" data-line-start=273 data-line-end=274 ><a id="mergeWith_273"></a>mergeWith</h3>
<h4 class="code-line" data-line-start=275 data-line-end=276 ><a id="_merge____RxJS_6_275"></a>Оператор <code>merge</code> был устаревшим в RxJS 6.</h4>
<pre><code class="has-line-data" data-line-start="278" data-line-end="298">import { interval } from &quot;rxjs&quot;;
import { map, merge } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(merge(count6To9$)).subscribe(console.log);
// (after ~1s) 1 (immediately) 6
// (after ~1s) 2 (immediately) 7
// (after ~1s) 3 (immediately) 8
// (after ~1s) 4 (immediately) 9
// (after ~1s) 5
</code></pre>
<h4 class="code-line" data-line-start=299 data-line-end=300 ><a id="_RxJS_7____mergeWith_299"></a>В RxJS 7 его заменил оператор <code>mergeWith</code>.</h4>
<pre><code class="has-line-data" data-line-start="302" data-line-end="322">import { interval } from &quot;rxjs&quot;;
import { map, mergeWith } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(mergeWith(count6To9$)).subscribe(console.log);
// (after ~1s) 1 (immediately) 6
// (after ~1s) 2 (immediately) 7
// (after ~1s) 3 (immediately) 8
// (after ~1s) 4 (immediately) 9
// (after ~1s) 5
</code></pre>
<h3 class="code-line" data-line-start=323 data-line-end=324 ><a id="zipWith_323"></a>zipWith</h3>
<h4 class="code-line" data-line-start=325 data-line-end=326 ><a id="_zip____RxJS_6_325"></a>Оператор <code>zip</code> был устаревшим в RxJS 6.</h4>
<pre><code class="has-line-data" data-line-start="328" data-line-end="344">import { interval } from &quot;rxjs&quot;;
import { map, zip } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(zip(count6To9$)).subscribe(console.log);
// (~1s apart) [1,6], [2,7], [3,8], [4,9]
</code></pre>
<h4 class="code-line" data-line-start=345 data-line-end=346 ><a id="_RxJS_7____zipWith_345"></a>В RxJS 7 его заменил оператор <code>zipWith</code>.</h4>
<pre><code class="has-line-data" data-line-start="348" data-line-end="364">import { interval } from &quot;rxjs&quot;;
import { map, zipWith } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(zipWith(count6To9$)).subscribe(console.log);
// (~1s apart) [1,6], [2,7], [3,8], [4,9]
</code></pre>
<h3 class="code-line" data-line-start=365 data-line-end=366 ><a id="raceWith_365"></a>raceWith</h3>
<h4 class="code-line" data-line-start=367 data-line-end=368 ><a id="_race____RxJS_6_367"></a>Оператор <code>race</code> был устаревшим в RxJS 6.</h4>
<pre><code class="has-line-data" data-line-start="370" data-line-end="386">import { interval } from &quot;rxjs&quot;;
import { map, race } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(race(count6To9$)).subscribe(console.log);
// (~1s apart) 1, 2, 3, 4, 5
</code></pre>
<h4 class="code-line" data-line-start=387 data-line-end=388 ><a id="_RxJS_7____raceWith_387"></a>В RxJS 7 его заменил оператор <code>raceWith</code>.</h4>
<pre><code class="has-line-data" data-line-start="390" data-line-end="406">import { interval } from &quot;rxjs&quot;;
import { map, raceWith } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(raceWith(count6To9$)).subscribe(console.log);
// (~1s apart) 1, 2, 3, 4, 5
</code></pre>
<h3 class="code-line" data-line-start=407 data-line-end=408 ><a id="concatWith_407"></a>concatWith</h3>
<h4 class="code-line" data-line-start=409 data-line-end=410 ><a id="_concat____RxJS_6_409"></a>Оператор <code>concat</code> был устаревшим в RxJS 6.</h4>
<pre><code class="has-line-data" data-line-start="412" data-line-end="428">import { interval } from &quot;rxjs&quot;;
import { concat, map } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(concat(count6To9$)).subscribe(console.log);
// (~1s apart) 1, 2, 3, 4, 5, 6, 7, 8, 9
</code></pre>
<h4 class="code-line" data-line-start=429 data-line-end=430 ><a id="_RxJS_7____concatWith_429"></a>В RxJS 7 его заменил оператор <code>concatWith</code>.</h4>
<pre><code class="has-line-data" data-line-start="432" data-line-end="448">import { interval } from &quot;rxjs&quot;;
import { concatWith, map } from &quot;rxjs/operators&quot;;

const count1To5$ = interval(1000).pipe(
  take(5),
  map(i =&gt; i + 1)
);

const count6To9$ = interval(1000).pipe(
  take(4),
  map(i =&gt; i + 6)
);

count1To5$.pipe(concatWith(count6To9$)).subscribe(console.log);
// (~1s apart) 1, 2, 3, 4, 5, 6, 7, 8, 9
</code></pre>
<h3 class="code-line" data-line-start=449 data-line-end=450 ><a id="__timeout_449"></a>Более мощный timeout</h3>
<h4 class="code-line" data-line-start=451 data-line-end=452 ><a id="_RxJS_7________________451"></a>До RxJS 7 мы могли сделать следующее, чтобы установить отдельный тайм-аут для начального значения, которое будет выдавать поток:</h4>
<pre><code class="has-line-data" data-line-start="454" data-line-end="471">import { concat, partition, timer } from &quot;rxjs&quot;;
import { first, share, timeout } from &quot;rxjs/operators&quot;;

const count$ = timer(3000, 2000).pipe(share());

const [first$, rest$] = partition(count$, (_, index) =&gt; index === 0);

concat(
  first$.pipe(
    timeout(5000),
    first()
  ),
  rest$.pipe(timeout(1000))
).subscribe({ next: console.log, error: console.error });
// (after ~3s) 0
// (after ~1s) Error: Timeout has occurred
</code></pre>
<h4 class="code-line" data-line-start=472 data-line-end=473 ><a id="_______________RxJS_7_______timeout__472"></a>Честно говоря, описанная выше последовательность управления была слишком сложной для такой простой вещи. С помощью RxJS 7 мы теперь можем передать объект конфигурации <code>timeout</code> оператору:</h4>
<pre><code class="has-line-data" data-line-start="475" data-line-end="486">import { timer } from &quot;rxjs&quot;;
import { timeout } from &quot;rxjs/operators&quot;;

const count$ = timer(3000, 2000);

count$
  .pipe(timeout({ first: 5000, each: 1000 }))
  .subscribe({ next: console.log, error: console.error });
// (after ~3s) 0
// (after ~1s) Error: Timeout has occurred
</code></pre>
<h4 class="code-line" data-line-start=487 data-line-end=488 ><a id="_____timeoutWith_____with___RxJS_6____487"></a>Кроме того, в объекте конфигурации <code>timeoutWith</code>, оператор устарел и заменен <code>with</code> параметром. В RxJS 6 мы делали следующее:</h4>
<pre><code class="has-line-data" data-line-start="490" data-line-end="498">import { timer } from &quot;rxjs&quot;;
import { timeoutWith } from &quot;rxjs/operators&quot;;

timer(5000, 1000)
  .pipe(timeoutWith(2000, of(&quot;timeout&quot;)))
  .subscribe(console.log);
// (after ~2s) timeout
</code></pre>
<p class="has-line-data" data-line-start="499" data-line-end="500">В RxJS 7 мы делаем это:</p>
<pre><code class="has-line-data" data-line-start="502" data-line-end="510">import { timer } from &quot;rxjs&quot;;
import { timeout } from &quot;rxjs/operators&quot;;

timer(5000, 1000)
  .pipe(timeout({ first: 2000, with: _ =&gt; of(&quot;timeout&quot;) }))
  .subscribe(console.log);
// (after ~2s) timeout
</code></pre>
<h3 class="code-line" data-line-start=511 data-line-end=512 ><a id="_resetOnSuccess____511"></a>Параметр resetOnSuccess для оператора повтора</h3>
<h4 class="code-line" data-line-start=513 data-line-end=514 ><a id="_RxJS_6_retry__________513"></a>В RxJS 6 <code>retry</code> в качестве параметра будет приниматься только количество повторных попыток.</h4>
<pre><code class="has-line-data" data-line-start="516" data-line-end="534">import { defer, from } from &quot;rxjs&quot;;
import { retry, tap } from &quot;rxjs/operators&quot;;

const values = [&quot;_&quot;, 0, 1, 0, 2, 0, 3, 0, 0, 0, 4];

defer(() =&gt; {
  values.shift();
  return from(values);
})
  .pipe(
    tap(i =&gt; {
      if (!i) throw &quot;ERROR&quot;;
    }),
    retry(2)
  )
  .subscribe({ next: console.log, error: console.warn });
// (synchronously) 1, ERROR
</code></pre>
<h4 class="code-line" data-line-start=535 data-line-end=536 ><a id="_________RxJS_7_____retry____resetOnSuccess_535"></a>Это число не сбрасывается после успешных попыток. Теперь, в RxJS 7 мы можем передать оператору <code>retry</code>, параметр с именем <code>resetOnSuccess</code>.</h4>
<pre><code class="has-line-data" data-line-start="538" data-line-end="556">import { defer, from } from &quot;rxjs&quot;;
import { retry, tap } from &quot;rxjs/operators&quot;;

const values = [&quot;_&quot;, 0, 1, 0, 2, 0, 3, 0, 0, 0, 4];

defer(() =&gt; {
  values.shift();
  return from(values);
})
  .pipe(
    tap(i =&gt; {
      if (!i) throw &quot;ERROR&quot;;
    }),
    retry({ count: 2, resetOnSuccess: true })
  )
  .subscribe({ next: console.log, error: console.warn });
// (synchronously) 1, 2, 3, ERROR
</code></pre>
<h3 class="code-line" data-line-start=558 data-line-end=559 ><a id="_Share_558"></a>Конфигурация Share</h3>
<h4 class="code-line" data-line-start=560 data-line-end=561 ><a id="_RxJS_7__share_____________shareReplay___shareReplay___RxJS_6_560"></a>В RxJS 7, оператор <code>share</code> получил довольно обширный объект конфигурации. Теперь, похоже, что больше нет необходимости в <code>shareReplay</code>. Вспомним, как <code>shareReplay</code> работал в RxJS 6:</h4>
<pre><code class="has-line-data" data-line-start="563" data-line-end="577">import { interval, of, zip } from &quot;rxjs&quot;;
import { map, shareReplay } from &quot;rxjs/operators&quot;;

const shared$ = zip(interval(1000), of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;)).pipe(
  map(([, char]) =&gt; char),
  shareReplay({ refCount: true, bufferSize: 3 })
);

shared$.subscribe(console.log);
// (~1s apart) A, B, C, D, E

setTimeout(() =&gt; shared$.subscribe(console.log), 6000);
// (after ~6s, all at once) C, D, E
</code></pre>
<h4 class="code-line" data-line-start=578 data-line-end=579 ><a id="_______share_578"></a>Посмотрим, как это сделать с новой конфигурацией <code>share</code>.</h4>
<pre><code class="has-line-data" data-line-start="581" data-line-end="600">import { interval, of, ReplaySubject, zip } from &quot;rxjs&quot;;
import { map, share } from &quot;rxjs/operators&quot;;

const shared$ = zip(interval(1000), of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;)).pipe(
  map(([, char]) =&gt; char),
  share({
    connector: () =&gt; new ReplaySubject(3),
    resetOnComplete: false,
    resetOnError: false,
    resetOnRefCountZero: false
  })
);

shared$.subscribe(console.log);
// (~1s apart) A, B, C, D, E

setTimeout(() =&gt; shared$.subscribe(console.log), 6000);
// (after ~6s, all at once) C, D, E
</code></pre>
<h4 class="code-line" data-line-start=601 data-line-end=602 ><a id="_____reset_____Observable____________resetOnRefCountZero______Observers______unsubscribe_601"></a>Свойства, которые начинаются со «сброса» (reset) в объекте конфигурации, позволяют <code>Observable</code> сбросить их, и снова становятся «холодными» при наступлении соответствующего состояния. Например, <code>resetOnRefCountZero</code> сбрасывает ресурс, если количество подключенных <code>Observers</code> снова становится равным нулю из-за <code>unsubscribe</code>.</h4>
<h3 class="code-line" data-line-start=603 data-line-end=604 ><a id="onnect__onnectable_603"></a>Сonnect и Сonnectable</h3>
<h4 class="code-line" data-line-start=605 data-line-end=606 ><a id="_RxJS_7____connect____Observable____605"></a>В RxJS 7 появился новый оператор <code>connect</code> для мультикаста источника <code>Observable</code>. Работает это так:</h4>
<pre><code class="has-line-data" data-line-start="608" data-line-end="637">import { merge, of } from &quot;rxjs&quot;;
import { connect, filter, map } from &quot;rxjs/operators&quot;;

const chars$ = of(&quot;A&quot;, &quot;b&quot;, &quot;C&quot;, &quot;D&quot;, &quot;e&quot;, &quot;f&quot;, &quot;G&quot;);

chars$
  .pipe(
    connect(shared$ =&gt;
      merge(
        shared$.pipe(
          filter(x =&gt; x.toLowerCase() === x),
          map(x =&gt; `lower ${x.toUpperCase()}`)
        ),
        shared$.pipe(
          filter(x =&gt; x.toLowerCase() !== x),
          map(x =&gt; `upper ${x}`)
        )
      )
    )
  )
  .subscribe(console.log);
// (synchronously) upper A
// (synchronously) lower B
// (synchronously) upper C
// (synchronously) upper D
// (synchronously) lower E
// (synchronously) lower F
// (synchronously) upper G
</code></pre>
<h4 class="code-line" data-line-start=638 data-line-end=639 ><a id="______connectable____ConnectableObservableLike__________638"></a>Также есть новая функция с именем <code>connectable</code>, которая возвращает объекты <code>ConnectableObservableLike</code>. Мы могли бы повторить приведенный выше пример следующим образом:</h4>
<pre><code class="has-line-data" data-line-start="641" data-line-end="668">import { connectable, merge, of } from &quot;rxjs&quot;;
import { filter, map } from &quot;rxjs/operators&quot;;

const chars$ = of(&quot;A&quot;, &quot;b&quot;, &quot;C&quot;, &quot;D&quot;, &quot;e&quot;, &quot;f&quot;, &quot;G&quot;);
const connectableChars$ = connectable(chars$);

const lower$ = connectableChars$.pipe(
  filter(x =&gt; x.toLowerCase() === x),
  map(x =&gt; `lower ${x.toUpperCase()}`)
);

const upper$ = connectableChars$.pipe(
  filter(x =&gt; x.toLowerCase() !== x),
  map(x =&gt; `upper ${x}`)
);

merge(lower$, upper$).subscribe(console.log);

connectableChars$.connect();
// (synchronously) upper A
// (synchronously) lower B
// (synchronously) upper C
// (synchronously) upper D
// (synchronously) lower E
// (synchronously) lower F
// (synchronously) upper G
</code></pre>
<h4 class="code-line" data-line-start=669 data-line-end=670 ><a id="______connectable______connector__resetOnDisconnect____________669"></a>При модификации на последнем подключенном элементе, <code>connectable</code> начал получать объект конфигурации с <code>connector</code> и <code>resetOnDisconnect</code> свойствами. Посмотрите, как мы отключаемся и снова подключаемся в примере ниже.</h4>
<pre><code class="has-line-data" data-line-start="672" data-line-end="714">import { connectable, interval, merge, of, Subject, zip } from &quot;rxjs&quot;;
import { filter, map } from &quot;rxjs/operators&quot;;

const chars$ = zip(interval(1000), of(&quot;A&quot;, &quot;b&quot;, &quot;C&quot;, &quot;D&quot;, &quot;e&quot;, &quot;f&quot;, &quot;G&quot;)).pipe(
  map(([, char]) =&gt; char)
);
const connectableChars$ = connectable(chars$, {
  connector: () =&gt; new Subject(),
  resetOnDisconnect: true
});

const lower$ = connectableChars$.pipe(
  filter(x =&gt; x.toLowerCase() === x),
  map(x =&gt; `lower ${x.toUpperCase()}`)
);

const upper$ = connectableChars$.pipe(
  filter(x =&gt; x.toLowerCase() !== x),
  map(x =&gt; `upper ${x}`)
);

function connect() {
  merge(lower$, upper$).subscribe(console.log);
  return connectableChars$.connect();
}

const connection = connect();
setTimeout(() =&gt; {
  connection.unsubscribe();
  connect();
}, 3000);
// (after ~1s) upper A
// (after ~1s) lower B
// (after ~1s) upper C
// (after ~1s) upper A
// (after ~1s) lower B
// (after ~1s) upper C
// (after ~1s) upper D
// (after ~1s) lower E
// (after ~1s) lower F
// (after ~1s) upper G
</code></pre>
<h4 class="code-line" data-line-start=715 data-line-end=716 ><a id="_connectable_connect__share______multicast_publish_publishBehavior__publishLast___715"></a>Теперь, <code>connectable</code>, <code>connect</code> и <code>share</code> являются достаточными для мультикастинга, а <code>multicast</code>, <code>publish</code>, <code>publishBehavior</code>, и <code>publishLast</code> операторы устарели.</h4>
<h3 class="code-line" data-line-start=717 data-line-end=718 ><a id="A_animationFrames_717"></a>Aнимация (animationFrames)</h3>
<h4 class="code-line" data-line-start=719 data-line-end=720 ><a id="_RxJS_7___observable___requestAnimationFrame__cancelAnimationFrame__animationFrames__________719"></a>В RxJS 7, есть новый <code>observable</code>, который оборачивает <code>requestAnimationFrame</code> и <code>cancelAnimationFrame</code> функции: <code>animationFrames</code>. Как следует из названия, он используется для создания анимации.</h4>
<pre><code class="has-line-data" data-line-start="722" data-line-end="759">import { animationFrames, combineLatest, concat } from &quot;rxjs&quot;;
import { endWith, map, takeWhile } from &quot;rxjs/operators&quot;;

const h1 = document.querySelector(&quot;h1&quot;)!;

combineLatest({
  x: tween(0, 200, 3600),
  y: wave(25, 1200, 3)
}).subscribe(({ x, y }) =&gt; {
  h1.style.transform = `translate3d(${x}px, ${y}px, 0)`;
});

function tween(start: number, end: number, duration: number) {
  const delta = end - start;

  return animationFrames().pipe(
    map(({ elapsed }) =&gt; elapsed / duration),
    takeWhile(percentage =&gt; percentage &lt; 1),
    endWith(1),
    map(percentage =&gt; percentage * delta + start)
  );
}

function wave(length: number, duration: number, repeat = 1) {
  const tweens = [
    tween(0, length, duration / 4),
    tween(length, -length, duration / 2),
    tween(-length, 0, duration / 4)
  ];

  const animation = Array(repeat)
    .fill(tweens)
    .flat();

  return concat(...animation);
}
</code></pre>
<h4 class="code-line" data-line-start=760 data-line-end=761 ><a id="_________760"></a>Простая анимация, созданная приведенным выше кодом, выглядит следующим образом:</h4>
<p class="has-line-data" data-line-start="762" data-line-end="763"><img src="https://miro.medium.com/max/2400/1*b1yn2ZJmQxv4-KJXyNIfYQ.gif" alt=""></p>
<h5 class="code-line" data-line-start=763 data-line-end=764 ><a id="RxJS_7_animationFrames_____763"></a>RxJS 7 animationFrames, перемещающие заголовок на странице</h5>
<h3 class="code-line" data-line-start=765 data-line-end=766 ><a id="configonUnhandledError_765"></a>config.onUnhandledError</h3>
<h4 class="code-line" data-line-start=766 data-line-end=767 ><a id="_RxJS_7__config___catcher____onUnhandledError_766"></a>В RxJS 7, объект <code>config</code> содержит асинхронный catcher для необработанных ошибок: <code>onUnhandledError</code>.</h4>
<pre><code class="has-line-data" data-line-start="769" data-line-end="777">import { config, throwError } from &quot;rxjs&quot;;

config.onUnhandledError = console.warn;
throwError(() =&gt; &quot;TEST ERROR 1&quot;).subscribe();
throwError(() =&gt; &quot;TEST ERROR 2&quot;).subscribe({ error: console.warn });
// (synchronously) TEST ERROR 2
// (asynchronously) TEST ERROR 1
</code></pre>
<h3 class="code-line" data-line-start=778 data-line-end=779 ><a id="__RxJS____778"></a>Пользовательские ошибки RxJS возвращают стек вызовов</h3>
<h4 class="code-line" data-line-start=780 data-line-end=781 ><a id="______RxJS__Objectcreate_____ObjectsetPrototypeOf______v630______IE10___2018____issue____________700beta5________780"></a>В начале статьи мы упоминали, что RxJS использует <code>Object.create</code> для пользовательских ошибок. Фактически, <code>Object.setPrototypeOf</code> использовался раньше, но при разработке v6.3.0 от него отказались для поддержки IE10. В октябре 2018 года было создано issue, где говорилось, что пользовательские ошибки теряют свой стек вызовов. Наконец, с 7.0.0-beta.5 стек вызовов был снова добавлен к ошибкам.</h4>
<pre><code class="has-line-data" data-line-start="783" data-line-end="790">import { EMPTY } from &quot;rxjs&quot;;
import { first } from &quot;rxjs/operators&quot;;

EMPTY.pipe(first()).subscribe({ error: console.warn });
// (synchronously) EmptyErrorImpl
// v6.6.7 has no call stack, but v7 does
</code></pre>
<h3 class="code-line" data-line-start=791 data-line-end=792 ><a id="_791"></a>Заключение</h3>
<h4 class="code-line" data-line-start=793 data-line-end=794 ><a id="_RxJS_7________________________________7_________4__5___5__6______RxJS_____793"></a>В RxJS 7 есть еще много изменений, но для полного обзора не хватило бы сил ни у меня, ни у вас. Я попытался собрать в этой статье то, что посчитал важным. Возможно, переход на 7 версию будет не таким драматичным, как переход с 4 на 5 или с 5 на 6, но я должен отметить, что RxJS теперь является стабильной библиотекой.</h4>
<h4 class="code-line" data-line-start=794 data-line-end=795 ><a id="_RxJS_7____________________TypeScript____________RxJS_7_________________794"></a>В RxJS 7 все еще много устаревшего, но, чтобы упростить обновление, разработчики ничего не удалили. Это отличная новость. Тем не менее, пользователи TypeScript иногда могут испытывать трудности. Я думаю, что имеет смысл перейти на RxJS 7 для текущих проектов. Я сделаю это для своих проектов при первой возможности, и вам тоже рекомендую.</h4>
<h3 class="code-line" data-line-start=795 data-line-end=796 ><a id="________795"></a>Надеюсь, это было полезно. Увидимся в другой статье.</h3>
<p class="has-line-data" data-line-start="797" data-line-end="798">Перевод статьи: <a href="https://medium.com/volosoft/whats-new-in-rxjs-7-a11cc564c6c0">https://medium.com/volosoft/whats-new-in-rxjs-7-a11cc564c6c0</a></p>
</body>
</html>
